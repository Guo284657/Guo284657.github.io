<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2026 新年快乐</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle, #1a1f35 0%, #050505 100%);
            font-family: 'Microsoft YaHei', sans-serif;
        }
        canvas {
            display: block;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.3);
            font-size: 12px;
            pointer-events: none;
        }
    </style>
</head>
<body>

<canvas id="canvas"></canvas>


<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let width, height;
    let particles = [];
    let fireworks = [];
    
    // 视频中的文案序列
    const textList = [
        "2026",
        "新年快乐",
        "辞旧迎新",
        "一寸欢喜",
        "愿新年胜旧年",
        "欢愉且胜意",
        "万事皆可期",
        "马到成功",
        "所有科目全部通过",
        "愿我们班级更加团结",
        "你好 2026"
    ];

    let textIndex = 0;
    let gap = 5; // 粒子间隙，数值越大粒子越稀疏（类似LED点阵感）

    // 初始化画布尺寸
    function initSize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', initSize);
    initSize();

    // 粒子类
    class Particle {
        constructor(x, y) {
            this.x = Math.random() * width; // 初始随机位置
            this.y = Math.random() * height;
            this.targetX = x;
            this.targetY = y;
            this.size = Math.random() * 2 + 1; // 粒子大小
            this.speed = 0.08; // 汇聚速度
            this.color = `rgba(220, 235, 255, ${Math.random() * 0.5 + 0.5})`; // 蓝白色调
        }

        update() {
            // 缓动动画：当前位置趋向目标位置
            this.x += (this.targetX - this.x) * this.speed;
            this.y += (this.targetY - this.y) * this.speed;
            
            // 简单的颤抖效果，模拟光晕闪烁
            if (Math.abs(this.targetX - this.x) < 1) {
                this.x += Math.random() * 0.5 - 0.25;
                this.y += Math.random() * 0.5 - 0.25;
            }
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // 烟花类
    class Firework {
        constructor() {
            this.x = Math.random() * width;
            this.y = height;
            this.targetY = Math.random() * (height / 2);
            this.speed = Math.random() * 3 + 4;
            this.radius = Math.random() * 2 + 1;
            this.color = `hsl(${Math.random() * 360}, 100%, 70%)`;
            this.exploded = false;
            this.sparks = [];
        }

        update() {
            if (!this.exploded) {
                this.y -= this.speed;
                if (this.y <= this.targetY) {
                    this.explode();
                }
            } else {
                for (let i = this.sparks.length - 1; i >= 0; i--) {
                    this.sparks[i].update();
                    if (this.sparks[i].alpha <= 0) {
                        this.sparks.splice(i, 1);
                    }
                }
            }
        }

        draw() {
            if (!this.exploded) {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            } else {
                this.sparks.forEach(spark => spark.draw());
            }
        }

        explode() {
            this.exploded = true;
            for (let i = 0; i < 50; i++) {
                this.sparks.push(new Spark(this.x, this.y, this.color));
            }
        }
    }

    // 烟花火花类
    class Spark {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 3;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.alpha = 1;
            this.decay = Math.random() * 0.02 + 0.01;
            this.color = color;
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += 0.05; // 重力
            this.alpha -= this.decay;
        }

        draw() {
            ctx.globalAlpha = this.alpha;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    // 核心逻辑：将文字转换为点阵坐标
    function createTextParticles(text) {
        // 创建一个离屏 Canvas 用来获取文字像素
        const offCanvas = document.createElement('canvas');
        const offCtx = offCanvas.getContext('2d');
        offCanvas.width = width;
        offCanvas.height = height;

        let fontSize = Math.min(width / 6, 150); // 自适应字体大小
        if (width < 600) fontSize = 60; // 手机端调整

        offCtx.font = `bold ${fontSize}px "Microsoft YaHei", sans-serif`;
        offCtx.fillStyle = '#ffffff';
        offCtx.textAlign = 'center';
        offCtx.textBaseline = 'middle';
        offCtx.fillText(text, width / 2, height / 2);

        // 获取像素数据
        const imageData = offCtx.getImageData(0, 0, width, height).data;
        
        let newTargets = [];
        
        // 扫描像素，步长为 gap (模拟点阵效果)
        for (let y = 0; y < height; y += gap) {
            for (let x = 0; x < width; x += gap) {
                const index = (y * width + x) * 4;
                // 如果透明度大于 128，认为是文字的一部分
                if (imageData[index + 3] > 128) {
                    newTargets.push({x, y});
                }
            }
        }

        return newTargets;
    }

    // 切换文字逻辑
    function changeText() {
        const text = textList[textIndex];
        const targets = createTextParticles(text);

        // 如果现有粒子不够，补充新粒子
        if (particles.length < targets.length) {
            const diff = targets.length - particles.length;
            for (let i = 0; i < diff; i++) {
                particles.push(new Particle(width / 2, height / 2));
            }
        }

        // 如果现有粒子多了，删除多余的
        if (particles.length > targets.length) {
            particles.splice(targets.length);
        }

        // 分配目标位置
        // 为了效果更酷，我们可以打乱一下分配顺序，或者直接按顺序
        for (let i = 0; i < particles.length; i++) {
            particles[i].targetX = targets[i].x;
            particles[i].targetY = targets[i].y;
        }

        textIndex = (textIndex + 1) % textList.length;
    }

    // 动画循环
    function animate() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; // 拖尾效果
        ctx.fillRect(0, 0, width, height);

        // 更新和绘制粒子
        particles.forEach(p => {
            p.update();
            p.draw();
        });

        // 随机产生烟花
        if (Math.random() < 0.03) {
            fireworks.push(new Firework());
        }

        // 更新和绘制烟花
        for (let i = fireworks.length - 1; i >= 0; i--) {
            fireworks[i].update();
            fireworks[i].draw();
            if (fireworks[i].exploded && fireworks[i].sparks.length === 0) {
                fireworks.splice(i, 1);
            }
        }

        requestAnimationFrame(animate);
    }

    // 启动
    changeText(); // 显示第一个词
    setInterval(changeText, 3500); // 每3.5秒切换一次文字
    animate();

    // 简单的交互
    document.body.addEventListener('click', () => {
        if (document.documentElement.requestFullscreen) {
            document.documentElement.requestFullscreen().catch(err=>{});
        }
    });

</script>
</body>
</html>
